在这个部分，我们将创建一个函数来开始拍卖，并创建一个函数来对NFT进行竞标。

### 开始
我们使用一些控制结构来检查是否满足条件，然后才允许卖家开始拍卖。

首先，我们检查拍卖是否已经开始（第49行）。如果已经开始并且状态变量`started`返回true，则退出函数并抛出异常。

第二个条件是检查执行该启动功能的帐户是否为卖方（第50行）。当他们部署合约时，我们已经创建了一个用于存储销售者地址的功能，并且现在可以检查执行`start`函数的帐户是否为销售者。如果不是，则抛出异常。

接下来，我们想将正在拍卖的NFT从销售者转移到合约中（第52行）。 我们将状态变量`started`设置为`true`（第53行），并创建了一个结束日期以结束拍卖（第54行）。在这种情况下，它将是从调用start函数开始的七天。我们可以使用像`days`这样的后缀来指定时间单位。如果您想了解更多关于时间单位的信息，请查看<a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units" target="_blank">solidity 文档</a>。

最后，我们会发出`Start`事件（第56行）。

### 竞标
在函数调用者进行出价之前，我们需要确保满足某些条件。拍卖必须已经开始（第60行），拍卖不能已经结束（第61行），并且出价（与调用相关联的值）必须高于当前最高出价（第62行）。

现在，我们想要在进行新的竞标之前存储当前最高竞标人的出价。首先，我们检查是否有投标人（第64行）。如果这个函数调用是第一次投标，则下一行将无关紧要。在我们的mapping `bids` (第34行)中，将键——投标人地址——映射到值——一个表示该投标人以前从未撤回过的ETH总金额的uint类型变量。如果存在投标人，则将最高竞买者(`highestBidder`)的上次出价(`highestBid`)添加到他们所做出所有报价(`bids`) 的总值中(第65 行)，然后再撤回。 我们存储了这些报价，因为我们希望允许投资者提取他们使用来进行报价，但不再是最高竞买者时所使用过的ETH。

接下来，我们将`highestBidder`设置为调用该函数的账户( 第68 行)，并将`highestBid`设置为其所提交的`bid`即与该调用相关联发送过来金额(第69行)。

最后，我们发出`Bid`事件(第71行)。

## ⭐️ Assignment

1. 部署一个NFT合约。您可以使用我们在“Solidity NFT Course” Learneth课程中创建的NFT合约。
2. 铸造自己tokenId为0的NFT。
3. 部署这个EnglishAuction合约。将NFT合约地址作为`_nft`的参数，`_nftId`设置为0，`_startingBid`设置为1。
4. 调用您的NFT合约的`approve`函数，并将拍卖合同地址作为to的参数，`tokenId`设置为0。这将允许该合约转移要拍卖的代币。
5. 调用您拍卖合约的`start`函数。如果现在调用`started`函数，则应返回true。如果调用`highestBid`函数，则应返回1。
6. 将可以附加到交易中的值设置为3 Wei，并调用拍卖合同的`bid`函数。如果现在调用`highestBid`函数，则应返回3。
