このセクションでは、トランザクションの送信と承認プロセスについて説明します。

## Modifier

コントラクトに新しいmodifierがいくつか加わりました。 1つ1つ確認していきましょう。

1. **`txExists` modifier:** (13行目) トランザクションが存在することを確実にします。 これにより、トランザクションのインデックスが`transactions`配列の長さよりも小さいかどうかを確認しています。 このセクションのmodifierについては、後ほど詳しく取り上げます。
2. **`notExecuted` modifier:** (18行目) トランザクションが実行されていないことを確実にします。 これにより、トランザクションの`executed`変数がfalseであることを確認しています。
3. **`notConfirmed` modifier:** (23行目) 呼び出すアカウントによってトランザクションが承認されていないことを確実にします。 これにより、トランザクションインデックスのマッピング`isConfirmed`で呼び出し元のアドレスがfalseかどうかを確認しています。

## トランザクション構造体

28行目に、`Transaction`という構造体があります。 構造体のメンバーとして、`to`、`value`、`data`、`executed`、`numConfirmations`という変数がそれぞれ格納されます。

## 承認のマッピング

37行目では、`isConfirmed`というマッピングがあります。 このマッピングは、各トランザクションの承認を追跡するのに使われます。 これは、所有者のアドレスのトランザクションのインデックスをブール値にマッピングしています。 このブール値は、所有者がトランザクションに承認しているかどうかを示します。

## トランザクション配列

39行目には、`transactions`という配列があります。 この配列は、マルチシグネチャ・ウォレットに送信されたすべてのトランザクションを格納するのに使われます。

## イベント

このコントラクトのイテレーションでは、4つの新しいイベントが加わりました。

1. **`SubmitTransaction` event:** マルチシグネシャ・ウォレットにトランザクションが送信されるたびに発行されます。
2. **`ConfirmTransaction` event:** 所有者によってトランザクションが承認されるたびに発行されます。
3. **`RevokeConfirmation` event:** 所有者によって承認が取り消されるたびに発行されます。
4. **`ExecuteTransaction` event:** トランザクションが実行されるたびに発行されます。

## submitTransaction関数

`submitTransaction`関数(78行目)は、ユーザーがマルチシグ・ウォレットにトランザクションを送信することを可能にします。 この関数は、3つのパラメータ `to`、`value`、`data`を取ります。  `to`パラメータは、トランザクションの受信者のアドレスです。 `value`パラメータは、送信されるEtherの量です。 `data`パラメータは、受信者に送信されるデータです。 所有者のみがトランザクションを送信できます。

85行目では、新しいトランザクション構造体を作成し、`transactions`配列にプッシュしています。そして、`SubmitTransaction`イベントを発行しています。 `txIndex`変数は、トランザクションインデックスを追跡するのに使われます。

## confirmTransaction関数

`confirmTransaction`関数(98行目)は、ユーザーがトランザクションを承認することができます。 この関数は、パラメータ「`txIndex`」を取ります。
また、3つのmodifier「`onlyOwner`」、「`txExists`」、「 `notExecuted`」があります。 `onlyOwner` modifierによって、所有者のみがトランザクションを承認できることを確実にしています。 `txExists` modifierにより、トランザクションが存在することを確実にしています。 `notExecuted` modifierにより、トランザクションが実行されていないことを確実にしています。

101行目で、`transaction`というローカル変数にトランザクションを格納しています。 そして、トランザクションの`numConfirmations`変数をインクリメントしてから、トランザクションインデックスの`isConfirmed`マッピングで、呼び出しているアドレスにtrueを設定します。 最後に、`ConfirmTransaction`イベントを発行します。

## executeTransaction関数

`executeTransaction`関数(108行目)では、ユーザーがトランザクションを実行することができます。 113行目で、トランザクションの承認数が必要な承認数以上であること要求しています。 そして、トランザクションの `executed`変数をtrueに設定しています。 最後に、`call`関数で資金を送信します。  トランザクションの値とデータと一緒に受信者のアドレスに`call`しています。 トランザクションが成功すると、`ExecuteTransaction`イベントを発行します。

## getTransactionCount関数

`getTransactionCount`関数(132行目)では、ユーザーがマルチシグネシャ・ウォレットのトランザクションの数を取得することができます。 `transactions`配列の長さを返します。

## getTransaction関数

`getTransaction`関数(136行目)で、ユーザーがトランザクションを取得することができます。 この関数は、このセクションの前半で説明したトランザクション構造体のメンバーを返します。

## まとめ

このセクションでは、トランザクションの送信、承認、実行プロセスについて説明しました。 submitTransaction`関数、`confirmTransaction`関数、`executeTransaction関数を調査し、それらが連携して複数のユーザーによって、トランザクションを送信したり、承認したりできることを理解しました。

## ⭐️ 演習: トランザクションの作成

「ACCOUNTS」ドロップダウンメニュー内の最初のアカウントに対して、2 Etherを送信、承認、実行するトランザクションをしてください。

1. 前回の演習と同様に、マルチシグ・コントラクトをデプロイします。 必要な承認数を2にします。
2. 前回の課題と同じように、任意のアドレスから4 Etherを送信してマルチシグに資金を供給します。
3. 「ACCOUNTS」ドロップダウンメニューで最初のアカウントに2 Etherの送信をします。  このトランザクションを(submitTransaction使用して)送信したら、`getTransactionCount` をクリックして、1つのトランザクションがあるか確認してください。もしくは、 `getTransaction`をクリックし、トランザクションインデックスで0を入力すると、送信したトランザクションを確認できます。
4. `confirmTransaction`をクリックして、トランザクションインデックスとして0を挿入します。 `getTransaction`をもう一度クリックすると、トランザクションが一度承認されたことを確認できます。
5. 2つめの所有者アカウントに切り替えて、トランザクションの承認をもう一度行います。 `getTransaction`を再度クリックすると、トランザクションが2回承認されているこを確認できます。
6. 最後のステップは、トランザクションの実行です。 `executeTransaction`をクリックし、トランザクションインデックスとして0を挿入します。 `getTransaction`を再度クリックすると、トランザクションが実行されたことを確認できます。 また、「ACCOUNTS」ドロップダウンメニューの最初のアカウントの残高を確認します。 現在、アカウントの残高が2 Ether高くなり、マルチシグネシャ・ウォレットの残高が2 Ether少なくなっているはずです。

**ヒント:**
トランザクションを送信する場合、値がWeiであり、_dataフィールドが正しく入力されていることを確実にしてください。 例: 2 Etherでは、「0x5B38Da6a701c568545dCfcB03FcB875f56beddC4, 2000000000000000000, 0x」のように入力します。