Solidityにおいて変数の値として、さまざまな場所にデータを保存できます。_メモリー_、_ストレージ_、_calldata_などがあります。

以前説明したように、値型の変数は、値のコピーが個別に保存されますが、参照型(配列、構造体、マッピング)の変数は、値のロケーション(参照)のみが保存されます。

関数で参照型を使う場合、その値が保存されるデータロケーションを指定する必要があります。 関数の実行の価格は、データロケーションに影響します。参照型からコピーを作成するのにはガスがかかります。

### ストレージ

_ストレージ_に保存される値は、ブロックチェーンに永久に保存されます。そのため、使用するのが高価です。

このコントラクトでは、 `arr`、`map`、`myStructs`などの状態変数(5、6、10行目)がストレージに保存されます。 状態変数は、常にストレージに保存されます。

### メモリー

_メモリー_に保存される値は、一時的です。また、ブロックチェーンに保存されません。 external関数の実行の間に存在し、その後破棄されます。 _ストレージ_に保存される値よりも安価です。

このコントラクトでは、ローカル変数である`myMemstruct` (19行目)、`_arr`(31行目)がメモリーとして保存されています。 関数パラメータでは、データロケーションである_memory_や_calldata_が書かれている必要があります。

### Calldata

_Calldata_は、関数の引数を保存します。 _memory_のように、_calldata_は、external関数の実行中に一時的に保存されます。 _memory_に保存される値とは対照的に、_calldata_に保存される値は変更できません。 calldataは、使用するのに最も安いデータロケーションです。

このコントラクトでは、パラメータの`_arr`(35行目)は、データロケーションが_calldata_です。 配列の最初の要素に新しい値を割り当てたい場合、`function g`(31行目)で行えますが、 `function h`(35行目)ではできません。 理由としては、 `function g `の`_arr` は、データロケーションが_memory_になっおり、 _function h_はデータロケーションが`calldata`だからです。

## 割り当て

### メモリーからメモリー

_memory_から_memery_へ割り当てるには、コピーではなく参照を作成します。 変数の1つの値を変更すると、他の変数のすべての値で同じデータを参照しているものは、変更されます。

`function f`(12行目)の内部で`myMemStruct2`という新しい構造体をロケーションが_memory_作成し、`myMemStruct` の値をこの構造体に割り当てると(19行目)、`myMemStruct2`のあらゆる変更は、`myMemStruct`の値でもまた反映されます。

### ストレージからローカルストレージ

_storage_から_local storage_での割り当てもまた、コピーではなく参照を作成します。

ローカル変数である`myStruct`(17行目)の値を変更すると、状態変数 `myStructs`(10行目)の値も同様に変更されます。

## ストレージとメモリー/calldata

_storage_と_memory_(または_calldata_)間の割当では参照ではなく、独立したコピーを作成します。

`function f`(12行目)内で、新し構造体 `myMemStruct3`をデータロケーション_memory_で作成し、これに`myStruct`の値を割り当てると、`myMemStruct3`の変更は、 `myStructs`(10行目)のマッピングに保存されている値に影響しません。

最初に述べたように、コントラクトの作成時に、ガス代に注意する必要があります。 ガス代を減らすために、ガス代が可能な限りかからないデータロケーションを使用する必要があります。

## ⭐️ 演習

1. `function f`内部にある`myStruct` メンバーの`foo`の値を4に変更してください。
2. `function f`の内部にデータロケーションが_memory_の新しい構造体`myMemStruct2`を作成し、`myMemStruct`の値を割り当ててください。 `myMemStruct2`のメンバー`foo`の値を1に変更してださい。
3. `function f`内部に、データロケーション_memory_で新しい構造体`myMemStruct3`を作成し、`myStruct`の値を割り当ててください。 `myMemStruct3`メンバー `foo`の値を3に変更してください。
4. 関数fが `myStruct`、`myMemStruct2`、`myMemStruct3`を返すようにしてください。

ヒント: 関数`f`で正しい戻り値の型が作成されていることを確認しましょう。