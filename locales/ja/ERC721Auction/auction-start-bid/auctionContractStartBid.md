このセクションでは、オークションを開始する関数とNFTを入札する関数を作成します。

### 開始

いくつかの制御構造を使用して、必要な条件が満たされているかどうかを確認します。その後、売り手がオークションを開始します。

まず、オークションが既に開始されているかどうかを確認します(49行目)。 既に開始されており、状態変数`started`が`true`を返した場合、関数が終了して例外を投げます。

2つ目の条件は、売り手が関数を実行しているかどうかを確認します(50行目)。 既に作成した関数が、コントラクトをデプロイした時に、`seller`状態変数にある売り手のアドレスを格納しており、現在のアカウントを開始している関数が売り手であるかを確認できます。 そうでない場合は、例外を投げます。

次に、オークションに出品されるNFTを売り手からコントラクトに送信します(52行目)。
状態変数を`started`から`true`(53行目)に設定し、オークションの終了日を作成します(54行目)。 この場合、start関数が呼ばれてから7日間とします。 時間の単位では、数値リテラルのあとに`days`のような接尾辞を使用することができます。 時間の単位について、より詳細に学びたい場合は、<a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units" target="_blank">solidityのドキュメント</a>をご覧ください。

最後に、`Start()`イベントを発行します(56行目)。

### 入札

関数の呼び出し元が入札を行う前に、特定の条件が満たされることを確認する必要があります。 このオークションでは、開始されいること(60行目)、終了していないこと(61行目)、入札(呼び出しに付随する値)が現在の最高入札額より高額であること(62行目)が必須条件になります。

それでは、現在の最高入札額を保存してから、新しい入札を行いたいと思います。
まず、入札者がいるかどうかを確認します(64行目)。 この関数の呼び出しが、最初の入札の場合、次の行は考慮しません。
マッピング`bids`(34行目)は、キーとして入札者の`address`をマップし、オークションで入札者が引き出す前に持っているETHの総額を表す`uint`の値がマップされています。
入札者がいる場合、`highestBidder`の最後の入札(`highestBid`)を引き出す前の合計入札額に加算します(65行目)。
入札者が最高入札者ではなくなった場合、入札者が入札に利用したETHを引き出せるように入札を保存しています。

次に、関数を呼び出しているアカウントを`highestBidder`に設定し、`highestBid`を呼び出し時に送信した値を入札額にします(69行目)。

最後に、`Bid`イベントを発行します(71行目)。

## ⭐️ 演習

1. NFTコントラクトをデプロイします。 LearnEthコースである「Solidity NFTコース」で作成したNFTコントラクトを使用します。

2. tokenId 0のNFTをミントしてください。

3. EnglishAuctionコントラクトをデプロイします。 NFTコントラクトのアドレスを引数である`_nft`パラメータにして、`_nftId`に0、`_startingBid`を1にしてください。

4. NFTコントラクトの `approve` 関数のパラメータで、オークションコントラクトのアドレスを`to`、`tokenId`を0にして呼び出してください。 これで、コントラクトがオークションに出品されるトークンを送信できるようになります。

5. オークションコントラクトの`start`関数を呼び出します。 `started`関数を呼び出すと、`started`を返すようになります。 `highestBid` 関数を呼び出すと、1を返します。

6. トランザクションに付加する値を3Weiにして、オークションコントラクトの`bid`関数を呼び出します。 `highestBid`関数を呼び出すと、3を返すようになります。