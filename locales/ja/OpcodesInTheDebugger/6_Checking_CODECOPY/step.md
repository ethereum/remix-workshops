ここでの目標は、ブロックチェーンにコードを保存することです。 EVMは、クライアント(geth、parity)に**Call Data**のどの部分を保存するかを命じる必要があります。   このステップでは、コントラクトからコンストラクタを除いたものを保存します(コンストラクタは1度のみ実行されるためです)。そして、保存される必要のなり入力パラメータも除かれます。

`CODECOPY`の最初のステップでは、バイトコードをメモリーにコピーし、そしてイーサリアムクライアントが消費できるようにします。  モグモグ！

ちょっと待ってください。 クライアントがバイトコードを**モグモグ**する前に、命令が必要です。モグモグすることを命じるオペコードです。 `RETURN` がモグモグするオペコードです！

一般仕様書に記載されているように、コントラクト作成の最後に、クライアント(geth、parity)は、`RETURN`オペコードによってターゲットされた値を取得して、デプロイされたバイトコードの一部にすることで**保持**します。

`CODECOPY`内に入ったら、次にある**スタック**の上部3つのアイテムを見てみましょう。

`0: 0x0000000000000000000000000000000000000000000000000000000000000000`
`1: 0x0000000000000000000000000000000000000000000000000000000000000055`
`2: 0x000000000000000000000000000000000000000000000000000000000000003e`

_あなたのスタックでは、`1`と`2`が少し違うかもしれません。  コンパイラのバージョンが異なることによって違いが生じているかもしれません。_

**`CODECOPY`のパラメータがこれらです。**

_codecopy(t, f, s)_ では、**s**バイトをコードの位置である**f**からメモリの位置である**t**にコピーすることを思い出してみましょう。

`0`はオフセットで、コピーされたコードを**メモリー**に配置する場所です。 この例では、(すべてのゼロ)のコードは、メモリーの最初にコピーされます。 (**t**)
`1` は、**calldata**のオフセットで、(**f**)からコピーします。
`2` は、コピーするバイト数(**s**)です。

`CODECOPY`が実行された後に、コピーされたコードはメモリー内で次のようになります(_step into_ボタンをクリックしてください):
`0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c63430005110032`  **この値を(X)として参照します**。

デバッカの**Memory**パネルを見てみましょう。
上記で示した0xの番号は、**Memory**パネル内で表示されものと違います。表示されるのは次のようになります:
0x0: 6080604052600080fdfea265627a7a72 ????R??????ebzzr
0x10: 31582029bb0975555a15a155e2cf28e0 1X ?? uUZ??U????
0x20: 25c8d492f0613bfb5cbf96399f6dbd4e ?????a?????9?m?N
0x30: a6fc9164736f6c634300051100320000 ???dsolcC????2??
0x40: 00000000000000000000000000000000 ????????????????
0x50: 000000000000000000000000000000a0 ???????????????
0x60: 00000000000000000000000000000000 ????????????????
0x70: 00000000000000000000000000000000 ????????????????
0x80: 00000000000000000000000000000000 ????????????????
0x90: 00000000000000000000000000000002 ????????????????

`0x0`、`0x10`などは位置を表しています。 隣の番号は、位置のバイトコードを表します。  疑問符マークに続いて、ランダムに見える文字と数字が続きます。  これは、**Remix**が文字列に変換しています。

それでは、最初の4つのバイトコードセクションを繋げると次のようになります:
**0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e0a6fc9164736f6c63430005110032**  最後のセクションは、`0x90`は、コンストラクタのパラメータとして入力した2があります。

**Call Data** パネルからの入力データは次のようになります:
`0x6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c634300051100320000000000000000000000000000000000000000000000000000000000000002`
**この値を(Y)として参照します。**

`(X)`は、元のcalldataである`(Y)`のサブセットであることを示しています:

`(X)`は、入力パラメータである`0000000000000000000000000000000000000000000000000000000000000002` (保存不要) を含まないcalldataです。
また、コンストラクタコードを含まないコードである`6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe` は、1度だけ実行される必要があります。

以上から、`CODECOPY`は、バイトコードをcalldataから抽出し、メモリーにコピーします。

次のステップに進みましょう。
