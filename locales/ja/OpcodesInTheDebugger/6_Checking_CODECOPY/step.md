ここでの目標は、ブロックチェーンにコードを保存することです。 EVMは、クライアント(geth、parity)に**Call Data**のどの部分を保存するかを命じる必要があります。   このステップでは、コントラクトからコンストラクタを除いたものを保存します(コンストラクタは1度のみ与えられるためです)。そして、保存される必要のなり入力パラメータも除かれます。

`CODECOPY`の最初のステップでは、バイトコードをメモリーにコピーし、そしてイーサリアムクライアントが消費できるようにします。  モグモグ！

ちょっと待ってください。 クライアントがバイトコードを**モグモグ**する前に、命令が必要です。モグモグすることを命じるオペコードです。 `RETURN` がこのオペコードです！

一般仕様書に記載されているように、コントラクト作成の最後に、クライアント(geth、parity)は、`RETURN`オペコードによってターゲットされた値を取得して、デプロイされたバイトコードの一部にすることで**保持**します。

`CODECOPY`内に入ったら、次にある**スタック**の上部3つのアイテムを見てみましょう。

`0: 0x0000000000000000000000000000000000000000000000000000000000000000`
`1: 0x0000000000000000000000000000000000000000000000000000000000000055`
`2: 0x000000000000000000000000000000000000000000000000000000000000003e`

_あなたのスタックでは、`1`と`2`が少し違うかもしれません。  コンパイラのバージョンが異なることによって違いが生じているかもしれません。_

**`CODECOPY`のパラメータがこれらです。**

_codecopy(t, f, s)_ では、**s**バイトをコードの位置である**f**からメモリの位置である**t**にコピーすることを思い出してみましょう。

`0`はオフセットで、コピーされたコードを**メモリー**に配置する場所です。 この例では、(すべてのゼロ)のコードは、メモリーの最初にコピーされます。 (**t**)
`1` は、**calldata**のオフセットで、(**f**)からコピーします。
`2` は、コピーするバイト数(**s**)です。

`CODECOPY`が実行された後に、コピーされたコードはメモリー内で次のようになります(_step into_ボタンをクリックしてください):
`0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c63430005110032`  **この値を(X)として参照します**。

デバッカの**Memory**パネルを見てみましょう。
上記で示した0xの番号は、**Memory**パネル内で表示されものと違います。表示されるのは次のようになります:
0x0: 6080604052600080fdfea265627a7a72 ????R??????ebzzr
0x10: 31582029bb0975555a15a155e2cf28e0 1X ?? uUZ??U????
0x20: 25c8d492f0613bfb5cbf96399f6dbd4e ?????a?????9?m?N
0x30: a6fc9164736f6c634300051100320000 ???dsolcC????2??
0x40: 00000000000000000000000000000000 ????????????????
0x50: 000000000000000000000000000000a0 ???????????????
0x60: 00000000000000000000000000000000 ????????????????
0x70: 00000000000000000000000000000000 ????????????????
0x80: 00000000000000000000000000000000 ????????????????
0x90: 00000000000000000000000000000002 ????????????????

`0x0`、`0x10`などは位置を表しています。 隣の番号は、位置のバイトコードを表します。  疑問符マークに続いて、ランダムに見える文字と数字が続きます。  これは、**Remix**が文字列に変換しています。

So if we glue the first four sections of bytecode together, we'll get:
**0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e0a6fc9164736f6c63430005110032**  The last section - `0x90` has 2 which is what I input for the constructors parameter.

The input data from the **Call Data** panel is:
`0x6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c634300051100320000000000000000000000000000000000000000000000000000000000000002`
**I'll refer to this value as (Y).**

This shows us that `(X)` is a subset of the original calldata `(Y)`:

`(X)` is calldata without the input parameter `0000000000000000000000000000000000000000000000000000000000000002` (we don't need to store this)
and without the constructor code `6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe` which should be executed only 1 time.

So `CODECOPY` extracts the bytecode from the calldata and copies it to the memory.

次のステップに進みましょう。
